Use destroy() interface in Mind code

Move LocatedEntity to common, and rename

Make LocatedEntity the sole base class for dealing with entities.
 * Move flags into LocatedEntity
   * Fix MemEntity to use flags instead of current bools.
 * Modify WorldRouter to use it throughout
 * Modify Property interface to use it.
 * Move remaining Property methods into LocatedEntity, de-virt modProperty
   and setProperty

Why does SpawnProperty not implement copy()?

traits on property to specify the name simply.

Providing there is no extra deps, move all the property access methods
into LocatedEntiy. It is possible this must wait until we stop using
the PropertyManager in modProperty.
 1) MemEntity needs flags, so let's have flags.
 2) MemEntity will need type properties to save RAM, so let it have them

Should entity class children be invisible to the client? Prevents it from
requesting things it has never seen yet.

See if we can create a Property<Map> class with extra interface, rather
like the generic methods added to TerrainModProperty

We don't need PropertyManager to be virtual. Just move all the functionality
into the base class.

Remove libcommon from WorldRouterintegration and
Rulesetintegration

Why does TeleportAuthenticator::removeTeleport check if I->second is null?

disconnectObject does not remove a non-Account ConnectableRouter from
the connection. Neither does it remove Characters.

Add checks to ensure unlinkExternalMind has the desired effect on movement.
Once these checks are in place, we can do the movement change more directly
without having to go via the mindMoveOperation phase.

Make [un]linkExternalMind return success, to indicate if an event should be
logged. Keeps logging of events cleanly in the server code.

Simplify CommServer by removing the Idle functionality, and making it
a stand alone class.
 - In Juncture.cpp we can get to it by the ServerRouting
 - In PSQL code there can be a reference to it in CommStreamListener.

The dynamic_cast, and other logic can be removed from Connection::operation
if it could be moved into Character::externalOperation. In order for this
to be possible, Link and ExternalMind move into common, and CommSocket
would need to move into a library. This removes an expensive dynamic_cast
from the path of every operation coming into the server.

Rename Script::operation for clarify. Needs to merge C++11 first, to
reduce chances of error. Then we can see how much operation is actually
called.

Appropriate clothing buff.
 - match the weather in terms of warmth
 - social bonus for not wearing battle gear

In FooOperation(), avoid calling FooOperation() in a parent class, as it
re-does the checking.

Ducplicated code in ServerAccount::addNewEntity; very similar to
Account::addNewCharacter.

Reverse the flow of the possess key on the server. Have it created on the
destination based on a secret, and passed back to the source server, and from
there back to the client.

A solid attempt at i18n, which different l12n for connections?

1. Make sure all retries have exponential backoff.
2. Make sure all periodic things have jitter.
  a) Metaserver query needs deterministics jitter, to ensure clients drift.
  b) AI needs smaller jitter for now
  c) Trees need bigger jitter, but again deterministic - same offset each
     time for a given instance.

Abstract rules. Tasks are already one type, but we need MOAR! recipes,
and designs and stuff.

Move Server (base of ServerRouting) reference into Link.
It needs to actually handle lobby dispatch first.

There are only very few places where ConnectedRouter::m_connection is used
as anything other than Link - should be possible to weaken the coupling.

Motion only ever uses locatio, so doesn't need entity ref

When coverage tells us 0% in a header, that is because the header had to
generate implicit default code - probably destructor.

Design a general purpose constraints mechanism, and have it inform
the physics system.

See if we can test CommStreamClient with null_stream

Move logic for reply ops from CommClient::objectArrived to Connection?
Would probably clean up the logic in CommClient, and allow send()
to be removed.

Name of server for negotiation purposes is done _every_ connection
in CommClient. Calculate it centrally.

Client connection can be made way more efficient by embedding the objects
as members, rather than using pointers. To this end, make Negotiate
a member, using a template arg. Make the stream type also a member.
Move all explicit listener related functionality to a subclass
of CommClient, leaving CommClient as the common, template base class
for CommPeer and the new class. Encoder could also be embedded, except for
the need to pass in the codec on construction - arguably bad design.

Now that the client is getting an info response to create, get rid of the
need to see?

On account connection, the call to MTRand to salt and encrypt the password
looks a bit expensive. Syscalls opening dev/urandom, which could block.

Intetionally surrender as many capabilities as we can in order to avoid
security issues.

Peer should probably store a lower level version of the hostname, rather
than the input to the resolver, thus ensuring the other party can connect
to the right place. Juncture stores the high level representation, and uses
DNS to resolve. This is correct, as it may need to re-resolve
later - the other server may have moved. Peer will get deleted if the other
servers address changes, and has to express an accurate version to the client.

In Juncture - tighten up detecting the failed socket condition.
Once we are connected to Peer, probably shouldnt have the m_socket pointer
any more, and need to make sure we are no longer connected to the signals.
Can we clear the socket signals?

Separate out CommPeer::connect into two trivial inline functions

There are many ways in which MemMap does the same job as WorldRouter.
Common base class?

Fix up WorldLoader so it can work with IG only. Requires support for
GetOperation in Creator

Optionally report back success in the form of Info on in-game ops with
serialno?

Improve Interactive to use serialno for responses

Bug: Not listening for IPv6 any more
Bug: Connecting doesn't fail over

Why isn't ExternalMind a ConnectedRouter

Re-factor login code so Session is the unique class rather than Account.
Constraining logins to be one per account may be sound policy, but it
should be policy rather than a hard constraint of the architecture.

BaseWorld, Property, TypeNode and Inheritance into rulesets? Everything else
in common is lower level.

Need to work out what to do with sections, vs rulesets when uploading and
storing rules at the server end.

Probably cleaner, and less globals to initiate ruleset load from the config
phase in main()

Why isn't trailblaze working?

Look into if installcheck-local can be used usefully to ensure all is in
order.

It's possible to add permissions and possibly even protection against
CPU overload into the scripting API. Permissions could be controlled by a
global context as well is flags on the objects

Consider moving WorldTime back to Python, or making it way more data driven

Create inherited types in the script API for common operations - actually
cheaper believe it or not

A given owning entity (Account/Admin) needs to keep track of the work it is
doing when doing a ruleset upload. The whole ruleset change should be
encapsulated into a transaction, with its own instance of RuleHandler etc,
and once done it should be possible to check for errors, commit, or not.
Writing rules to database should only be done if transaction succeeds, so
all pending writes need to be encapsulated too. This requires the handler
and builder code not to be in server.

These class belong at the simulator layer (above rulesets,
                                           but not server specific):
  EntityBuilder, CorePropertyManager, *RuleHandler

Add a Server config class in server/ which adds all the base EntityFactories
to the builder, and the PropertyFactories to the CorePropertyManager. Then
both those can be made independant of server. It could also handle all the
really core types being added to Inheritance.

Is PyCreator/PyCharacter still needed in the client side? It seems to have
been abandoned before being fully introduced.

Add Arithmetic functionality to all scripts. Cos you know.
Add the concept of the Property script in general and use it to replace the
un-flexible concept of a specific Arithmetic script type.
It may be just more efficient to ignore this concept for most scripts,
but will almost certainly simplify the code to add it to many.
A more flexible concept of scripting attributes might make sense too.

Move to a mechanism like the new mind property for statistics

Ensure PythonClass checks base on reload
 - What happens when package changes?
 - What happens when class _name_ changes?

Make all PyProperties into an inheritance tree, and all scripts to
inherit from them
 - add tp_base
 - one aspect is that the property value itself is typically important
    as_number/as_seq/as_map ?
 - make properties scriptable and the move common code from Entity, Task
   and Property into Scriptable base class for multiple inheritance
 - It should be possible to simplify Py_Property.cpp function now

Add tests which trigger possible crash conditions in the script interface

Make m_target private in TaskFactory, and change the sort function for the
target map in activations to sort on how deep the target is in the
type tree, so we can try and get the closest match first.

Include doxygen docs in http self-served docs.

De-dup code in Py_Thing and Py_Mind and Py_CreatorClient

Make it possible to forget

Allow target to be "foo.bar" where foo is the entity type, and bar is property
name, allowing either to be unspecified. That way activation can be constrained
to a particular entity, a paricular property or both.

In NPCMind need to sort what is going on. Probably only need to hold onto
weak references using WeakValueDict

Use "name" as the property that is supposed to get an operation

It looks like weak reference is being broken way late in Logging. Probably
because the op queue is holding a reference to the tree, and so deleting 
the tree wrapper is being delayed. Need to look into when we delete that.

EntityBuilder shouldn't need a permenent reference to the world.

Allow long cut and cross cut with saws. Long cut is along grain, bisecting by longest dimension. cross cut is across both grains

Sort out a better way to handle materials. We shouldn't have a base class
the same as an attribute without the entity hierarchy, but being able to
declare attributes, and have definition data would be necessary. Good sample
case for having proper data driven, scriptable properties.

use boost intrusive containers for op queues

Check out _GLIBCXX_DEBUG
  Turns out to be useful to detect usage issues with STL, but requires full
  rebuild of everything that uses stdc++, including non WF deps.

Macro todo list
  Get server physics kicked off
  Re-work Atlas to be more secure, client driven encrypted
  Make server more modular, scalable

Protocol revision:
  Stop announcing by server, request at client instead
  Consolidate negotiation, and allow other undefined headers
  Allow for multiple exchanges during negotiation
  Put Unseen and other common ops (between Eris/cuphesis) into the spec

Use SCMS like scheme to ensure no grey goo. entities cannot create other
entities which can create further persistent entities.

Bullet Physics Ideas:
  There are two suitable bullet world objects for us to use:
    btCollisionWorld and btDynamicsWorld

  The former should be pretty simple to use, the latter gives way more.

  The former we can use by adding collision objects for the static world
  content, then use convexSweepTest to calculate collisions for single
  moving avatars which themselves do not need to be in the collisionWorld.
  It can also be used to avoid object intersection at movement and creation
  time if desirable.

  In a more advanced implementation, perhaps using btDynamicsWorld a bunch
  of interesting stuff can be simulated without us having to change the
  way we handle basic avatar collisions. In addition as things get more
  tricky we can use the bit field and matric features to define what collides
  with what, all under the control of the designer/builder.

Frontends, backends, routers based architecture

Use 64bit milliseconds everywhere. Merge SECONDS and STAMP into a single
attribute. Get rid of FUTURE_SECONDS in favor of things being able to set
STAMP/SECONDS in advance. Use time for STAMP instead of incrementing integer.

Character should inherit from and implement the Agent interface, which
the server code uses when talking to it. This de-couples server from most
of the rulesets directory.

If we want to support loading data and config over network, make the loader
classes abstract so the underlying implementation for getting data can vary.

Add config option which allows server owner to control the type of account
created by default. If they want "admin"/"builder" then they should have it.
In fact "builder" is a smashing idea for a new account type.

Use weak references to allow players to assist other players. Activating some
kind of assist task installs a reference in the other task, which breaks
automatically when the task breaks.

Harmonize Atlas repr of Areas with mods, and also fix bindings and properties
to make exchanging data easier.

Add new kind of marker area, only used internally to track things about
bits of terrain, like ownership. Requires new class in Mercator probably.

We should say "circle" to reference WFMath::Ball in 2D. Pick a different name
depending in dinension. "rectangle" instead of "box" perhaps.

Consider Entity:destroyed and Entity:containered to interrupt tasks

Allow Admin to use an op - perhaps Login - to claim any object on the server.

Use Java object builder/aspect pattern for Property factories in
CorePropertyManager

It looks as though Look FROM account is required to activate a possess key,
which I was not expecting. Are clients expecting this?

Add database stuff to store server metadata like version of server,
(to detect rolling back to earlier versions).

TerrainModProperty:
Do the same for areas.
We need op post-processing rather than pre-processing for move updates.

Abstract entities for tracking non-physical concepts such as quests, trade
transactions, entity recipes, contruction blueprints etc.
See http://www.igda.org/newsletter/?p=483 for how to do trading.

Extend Mercator to allow terrain mod volume calculations. Use these to work
out when a quarry should work, and how much it should be extended.

Sort InnerTerrainMod with very thorough tests (check pre/post), then try
and refactor.

Delve goal established pattern for picking up existing terrin mods.
  Add additional parallel mechanism for picking up areas.
  Use areas and mods a whole load more for construction projects.
  Returning the entities will be vastly more useful, so do that.

CommPythonClient should probably execute python in dispath rather than read()

Rename ArithmeticScript as Arithmetic

Inheritance::isTypeOf(TypeNode) can have a tighter loop

What are we doing with spawns?
Set location
Restrict classes
Setup inventory
Filter and modify character names.

Implement a null Atlas::Bridge which just does nothing.

Note that the SystemAccount will probably cause problems during character
creation, as the system will try and persist characters, and referential
integretiy will be bad, as the account itself is not persisted.

Make cycmd stop dumping all ops to output unless monitoring is on,
and stop it re-writing the prompt so much.

cyclient - add interactive
         - add args on commandline

CommServer::addSocket shoudl return success/failure, so that parent knows the
score.

Constrain movement if not directly in a movement domain.

Tower defense game.

Use PGconnectStart for async db stuff.

Internal "perceptive" property, which stores a set of currently visible IDs,
and can be used to send appearance/disappearance ops. Should cut down to cost
but increase storage.

A Dungeon Master like play style, where lots of minions are available to
dig and build dungeons, which a classic dungeon crawl mechanic for heros
in the Diablo style.

We really need to expose mind state better.

Add functionality to handle ids in blocks or ranges.

Does _anyone_ use Atlas::Objects iterators?

EntityFactory::m_children is only used in updating children properties, and
probably could be done by look up the children in Inheritance.

Separate the rulesets loading code out of EntityBuilder, making EntityBuilder
vastly simpler. Remove unused headers from EnittyBuilder and Ruleset.

It makes increasing sense to make the python subsystem behave a little
differently in the client:
 1) Allow all operation types in client, but error on unknown in server.
 2) Redirect Python output via logging mechanism in server, but not in client.
Needs to be done to make things sane.

FOO_NO numbers for operation classes are currently initialised to zero,
meaning they get missed in valgrind tests for non-initialised data.
Remove the initialisation and see what happens with valgrind now.

Minds which are asleep currently ignore all updates. This is a bit mad,
as it means we waste storage on what is inevitably going to be an outdated
world view. Either keep it updated, or just purge it completely.

Use a hidden property giving a list of worker IDs to establish common
state with tasks.

It might be useful to expose task attributes so they can be modified by
the task script itself, and ensure this propagates immediately back to
the client UI.

Add a single function for handling all those mind ops which just need
TO setting.

Check all Python for InstanceType, as that is what C++ objects used to be,
but not any more.

Client bindings don't belong in server module, and server module should
not be available at all in the client bindings.

Look into loudmouth for XMPP stuff.

Fix Arithmetic and Mind code so the factory is not created every time,
nor the type looked up every time. Python related factories need to be way
more consistent.

Look through dynamic casts and consider when it would be cleaner to
extend the interface in the base class.

Go through Python types sorting out where tp_methods can be used.
Sort out weak references for Entity and related wrappers,
Move Location into server, and isLocation somwhere else.
Many types have their own tp_new, but could be using _GenericNew.

Mind interface is pretty simple, so it should be possible to have a hive or
herd mind at either core or python layer. One significant goal will be to
eliminate the copy of the world per individual, but this is being done
already. It will probably e a major bonus to have a single view of the
world from all the entities, so that if one entity has seen something, they
are all considered to have seen it implicitly. In order for many things to
work these still need to make their own decissions though there is
collectivism to their movement decisions.

Touched on before, but why not break down clustering by the kind of computation,
so the physics layer is separated, and can only be talked to by RPC?
Another idea - separate the frontend with it's checks and socket handling
from the worldprocessing code. Connection, Account, Lobby etc would all be
handled in a frontend server with multiple processes. They share one listen
socket, and use herd of elephents prevention to listen to sockets. The then
send operations to a backend server which has the world processing.

WorldTime and DateTime need to be purely data driven

Implement connection limits.

Fix misspelling in Motion::getPostion()

Ensure that distance functions mark results as invalid if there
is a broken entity hierarchy.

Ways to hold territory:
 NPC manned towner foritifications. No door or ladder at ground level.
 Must be frequently re-supplied.

Define class properties that generate a random instance value per entity.
This is another type which must be added to every instance, and can never
be used as a default.

Look up launchd.plist man page for details of how to manage a unix daemon
under OS-X.
http://developer.apple.com/technotes/tn2005/tn2083.html

Add daily option to the create_release file, and work out where the hell to
put them.

--conf=<file> for specifying config. Simple.

Add a class for the movement domain which is a property of the movement
parent. Point to it from the Motion object. (safe reference).
Encapsulate most data related to movement in Motion rather than leaving
it to clog up Location.

Fix up cycmd to work more like cydb.

Move account update functionality into AccountBase. Keep cypasswd as the
user facing tool.

Look up using ares for asynch DNS. Possibly is skstream once that
does other stuff.

Look up Proactor pattern, Bloom filter.

How to support phasing? (Instancing so that the same place changes
fundamentally only to a subset of players)

Paxos algorithm for consensus (master election) in an unreliable distributed
system.

Modify metaserver to allow DNS queries.

Strip out the hierarchical movements domains. Flat!
The movement domain then handles collisions and line of sight
checking.

Areas of world with an associated in-game chat channel.

Connection, Master and Peer (and implicitly TrustedConnection) have members
in common, and could probably stand to inherit from a common parent.
Connection would make sense as the parent, moving stuff related to being
connected to a client to a child class UserConnection.

Add a way to extend the terrain base on where someone is walking.
Probably should sit on top of a general mechanism for modifying the
world based on player activity.

Fix out type updates in Eris. Need to be picked up in the special place
where serverinfo updates are picked up no.

Python console will make everything so much more introspective.

Remove the implicit bbox. Replace with coding the bbox property to set up
the visibility metric when applied.

OpQueEntry could be a conventional C style queue. Would be more efficient as
we are searching by hand already.

As noted before, ArithmeticFactory ScriptFactory and TaskFactory contain
much common code. Use inheritance.

Move the functionality from Statistics into StatisticsProperty, getting
rid of the class completely. Make it the simplest possible interface for the
python script, then see if this can be generalised for more broadly
applicable stuff. Python properties?

Allow generic simulated entities which have a real ID, but are not yet in
the world. The server will track them for you, and control varies depending
on privs. e.g. admin can create arbitrary simulated entities, and then insert
them for real. simulated is a bad term because in fact the difference is that 
they are _NOT_ simulated.

seq is not restored.

Properties added by requirePropertyClass and perhaps related functions
are not getting installed or applied.

Currently properties are being installed early before all Entity IDs have been
restored. Need to delay. This will be a problem if there are Entity properties
around linking things together by pointers.

Make operations that depend on newId generation failable, so that a
database issue does not cause an assertion to fail.

Make sure property names are limited to 32, and also class names to the same
length. Make this 32 limit a compile time constant. Also check ruleset name
length.

Fix abort() in newId() when Database connection is down. Probably best done
with an ID pool.

Make non-value related members of a TerrainModProperty mutable, so
they can be modified without having to get a non-const pointer.

modProperty should handle setting the flag_unsent flag on properties.

Central Knowledge, available to all NPCs without being taught.

Add SIGINT handler to cycmd to cancel tasks.

Doxygen TODO lists!

All the in-place property mods are not handling apply()
Should this be done in Update()?
updateOperation could handle setting clearing the per_clean flag, the
entity_clean flag, and apply the properties.

add_map really has no code in it
update_map contains very little and is probably obsolete as it never gets
called
Review hooks and see if they really are needed.
Note that:
 in sight_create_operation all that is being checked for is if we created it
 If we did create it, this is going to be a special interest to any mind
 so we could look at supporting it in the core base class.

 in sight_move_operation we are looking for changes to the inventory
 and taking ownership. Could this again be supported in the base code?

 Both sight_move and sight_create update the map via the Python API
 when this could be more efficiently done in the C++ if the op
 handler wasn't overriden. Why not assume the python handler does not
 override?

 The overall concept of overriding from scripts and also from handlers
 probably needs to be looked at.

Num property to implement stuff. Only works if it is installed as a class
property, otherwise does nothing. (Resets to one).
Value of one means nothing is sent.
Installing class causes instance property to be placed, but install is
not called on it.

Purge stackable.

Fix the stamina property, currently commented out.

Clear set ops out of tasks (in Character) and combat.
Can probably get rid of the hard Task pointer while at it.

In Plant.cpp a lot of properties are directly updated. Need to review
whether apply() and install have to be called on them.

Add an entity flag to indicate that the entity has been modified in
the python API, and on returning to core context an update needs to
be triggered.

Move requireSpecificProperty() and have it check on the defaults for
a default value.

Update Thing::updateProperties so it checks all properities to see whether
they've been written to the database. May need to trigger a database update.

Re-work the python wrappers to handle generating the necessary update flags
when modifying an IG entity. Complete different from the wrapper behavior
in the mind, which should probably no implement setattr at all.
It may need to generate Update or perhaps even Set operations as necessary.

Use a property flag for removing properties.

Fix up OutfitProperty to work with the modified API and conventions.
It can't really be a class property as it has entity refs, so I guess
it must be instance only. install() might like TerrainModPropery()
detect the case of a class version, and ensure that it is added as
an instance property.

Cutting down simulation cost when nothing is watching.
Gorgious. Send out a ping, and get back an estimate. at the simplest level
the simulation can continue, but decline to send out update ops. Kick off
an update in response to any subsequent look ops. Seq is being incremented
so Appearance will tell minds they need an update.

Make the overall movement model configurable. If a flat world is all that is
needed, there is no need to add more. In a fantasy MMO there is probably very
little need for more. There is a strong link here between this and the need
for persistence. If we only need character persistence, we can't really deal
with them having something other than the world as their LOC.

Define an operation which went sent returns the count of entities which
can see something, so we can suspend simulation.

If properties are responsible for their own serialisation, the represations
can be much more efficient.

Re-enable mapping of character to account.

Design a way to make only the starting POS and ORIENATION of an entity
storable.

Sort out enable_persitence. Purge the old code.

TerrainModProperty needs state, so it must be an instance property.
This can be handled in ::instal() once class properties are flagged.

Use database to allow characters to go offline.

Location is stil adding bbox data to RootEntity or MapType representations.
Stop, as this should be handled by the property.

Make sure all the places properties are set use one single way to do
it, ensuring the right calls get made to set it up.

Some entities (Character) may end up updating a class property and
then we get an error when the Update op arrives for an undiscovered
property. This also corrupts the class.

requireSpecificProperty installs new properties. Need to make sure it does
it correctly.

Think carefully about what happens when EntityBuilder::installFactory
calls Inheritance::addChild. If add child returns NULL, there
was something wrong with the factory installation and it should fail.

isSimple() and isSolid() should be entity flags, once the collision
stuff is sorted.

Modify client code which inherits from Entity so it uses LocatedEntity
or summink instead, removing the need for ClientPropertyManager.

Fix the insert properry count. Incremented in the wrong place.

Use return value of Property::get to ensure we are not storing
worthless data in the properties table.

Check use of the property manager in Character when adding status property.

Implement flag_class in EntityBuilder.

Once things are sorted for the new property mechanism, with install and apply
implemented, 

insertEntity and updateEntity are returning the bool result of scheduleCommand
incorrectly.

Perhaps we can use property flags for Update ops, rather then the cludgy
going through strings?

Remove assertion from CorePropertyManager that a property called objtype
can't be created.

Implement transient to avoid Database traffic.

Make sure the select fallback code handles congested and busy ok.

Sort out http connection with a configurable port.

Make it so classes inherit python scripts, now that the factory is independant
of atlas type name.

Need a property flag to indicate that it is new, rather than just dirty.

Make update interval has jitter on it, so we don't get spikey load.

Types should have integer IDs. Bootstrap type queries with well know IDs for basic types.

Admin Creator avatatar gets destroyed once it is no longer connected, but
it then calls Connection::removeObject() despite the Connection being
long gone.

Use a broadcast cost heuristic to determine how often movement updates should
done for an entity.

Migrate everything out of BaseEntity until nothing remains, at which point
rename it to IdentifiedRouter or something like that, inheriting from
Identified. LocatedEnity should eventually not inherit from it.

rename removePlayer to something more suitable.

Once defaults work, handle pulling from defaults in the SpecificProperty
templates.

Fix the issue of leaked sigc++ connections, as connections to tool.containered
are added, but never disconnected.

Fix the rest of defaults on the TypeNode.

Use onFoo() methods to implement some of the signals we expect.

Quaternion and BBox need to be more like Vector3D and Point3D, and all 4 should
really be in physics.

In a compound object, that contains sub-objects, COMPONENTS can be like
CONTAINS, but COMPONENTS do not have a separate existence. They are destroyed
if the entity is destroyed, and do not have globally addressable IDs.
They can still be represented by Entity, but won't be in the global ID
dictionary. This leads to the idea of a component property interface whcih
abstracts looking up component IDs. An accompanying stamp can reduce the
frequency with which clients need to inspect the components, as they should
change very infrequently.

SEQ is not being used in the memmap code, as it is not being set.

Re-write plant using properties when we can write scripts for property
handlers.

Character::m_rightHandWield needs to stop being hard coded. Should
be really easy to do. Make it a dynamic property always, add install
it as required.

B&W style village construction. Nursery, plus schools for training.

Re-factor abstract factories to be called Kits, and high level factories that
assemble arrangements of objects as Builders. Concrete factories can then
use the suffix factory.

Put locks around writing the user config file.

Move bbox out of Location, and make it a soft property only.

Add instance configuration support to tools and clients.

Add setting for config file.

openID, libopkele
echo -n 'username:phpMyID:password' | openssl md5

Separate functionality for removing from container, and adding to new
container.

Modify security in NPCMind so we can do the goals without broadcasting the
talk ops. Use the TO on the Talk op to determine if this is an admin op,
so that clients can redirect ops easily. Need to verify that checking
Sound.FROM is the only reason interlinguish functions need the op. It
may be possible to get rid of passing in orignal_op completely.

New Atlas-C++ has no inheritance tree, just one class in Objects. Instead
it has function to create the instances, which create the defaults object
if required, pass it in, and return a smartptr to an instance from the pool.
Convenience versions of these function could take op arguments for operations,
or IDs or the like for entities.

Activations should use type nodes perhaps.

Check if SECONDS is set before using it? All ops in basemind should do this.

Add an argument to Location::addToEntity which specifies which need to be
set as zero values of they are not set. This should make it easier to
deal with the concept of POSless entities, and perhaps entities without
velocity. Would be nice to get rid of any situation where something has
zero velocity, as this is annoying to have to check for.

Fix new PythonArithmeticScript() from being leaked. ArithmeticFactory(124)
Shader surfaces are being leaked from TerrainProperty::set(130)

Switch over to using Atlas::Objects as the fundamental unit in the objects
code. Needs AtlasFileLoader to be converted over. This is the best first step
before we have a type tree. Done. Now get rules loading from the Database once
more, as the database code insists on MapType. Could we store the attribute
defaults in the Atlas default type thingy? Would this cause problems?
So, when we are creating a Atlas::Objects::Anonymous instances, need to
be able to set up the default object so it just works. A barrier to this being
really useful is the way Atlas-C++ currently handles defaults. It does not send
them at all. Need to modify so it sends them if they have been flagged on
the defaults object. Default to not flagging, and then modify sending behavoir.
Think about using an inherited interface to prevent calling getName()
which might cause a crash.

Core cyphesis daemon is very simple and robust. Never crashes. It launches
and monitors and number of child daemons. Simplest configuration is a single
child daemon. It reads and parses the config mostly for checking purposes.
Write common infrastructure which can check the contents of the config
for errant values, and report them. Use the current help data structures.
There should in the eventual configuration be one watcher daemon, one
simulation daemon, one persistor daemon, and one spatial processing daemon per
CPU. Simulation should be network bound, peristence should be disk bound, and
spatial should be CPU bound.

Experiment with factory base classes. Can we have a base class for BaseEntity,
inherit from it overriding with a function that returns Entity.

Datagram classes in skstream, Address classes in skstream. Datagram can be
sent to an address, without re-encoding. Datagram can be treated as stream.
Address can encapsulate getaddrinfo results, or stand alone endpoints.

There need to be two different filters on movement. The first pass should
determine what is possible given the desired input. The second should
determine side effects of the movement. Can we really separate them, given
that the side effects modify the effort and possibility of the movement?

Blocking movement thingies are going to have to go. Handling move ops should
just schedule the move. We pass to some collision subsystem, and then send
the result once the result it back.

Make IGEntityExerciser succeed in stimulating the Create op.
Make IGEntityExerciser succeed in stimulating the Move op.

Create a simple class that fully encapsulates having a python script in
a general way, which can then be used by entity, task, statistics etc.

EntityFactory has got really convoluted. Try and verify that the same things
are done when a tool is updated as when it is loaded. May be good to break
things down into smaller functions.

script_factory->refreshClass is called before populateFactory(). Seems weird.
Surely the script might have been changed? If it has, what causes it to be
loaded?

Fill out auto activation op stuff. Now that operations is automatic,
need to ensure children inherit the behavior as well as the value, which
requires some work on the activations.

In EntityFactory, we should abort a task install if the target does not exist.

Add unit tests to make sure rule install order with multiple dependencies
is okay.

Write a task to beat down fire with shovel.

Specify contents of the house in the class rule, rather than using the script
to create it. Contained entity data format again, just like blueprint.
CONSTITUANTS?

Add a transient property which indicates that something does not last, and
should not be persisted. This would allow most of the seed scripts to be
removed.

There is a chance something could get screwed up in waitingRules.
If something depends on two classes, and the second is not present the first
time it fires, m_waitingRules will get modified mid iteration, and then
the waiting item will get removed despite the fact that is has not been
installed.

When a task cannot be installed because of pre-reqs, record the error so
it can be reported.

Push to remove the world class, making it all more driven by data behavior.

POS can't change in Dig and Delve, so make them irrelevant if its not the right
kind of terrain.

Add range check to Dig and Delve, and see if it can be done more generally.

Re-write goals for butcher so they now interact correctly with the task
implementation.

GetOp is not part of IG, so illustrates for OOG dispatch to be different from
IG.

Apply behavior to newly created skellys. Now that the mind classes have been
removed, skeletons need goals to do anything.

Implement blocking rules until all associated rules can be verified so
tasks can't get installed without their activation ops and classes existing.

self.progress seems to start out at -2 in Slice. Uninitialised?

Add a way to handle per-host config in a single config file.

Fix parameter lookup in varconf.

Add a call to Atlas-C++ which takes a bit field of attribute bits, and returns
a bitfield of attribute bits that was requested but not present. Reduces
error checking complexity loads.

Pig seller seems to assume he is being given coins when actually they
are being handed round by other people.

Look up in Python Nutshell and read up on ref-counting + exceptions. Read
whole section on embedding.

ServerRouting owns accounts currently, so have it encapsulate the whole
database thing. Check if the findAccount test is a good reason not to do
this.

metaserver needs to reinitialise if bind is lost.

Make sure autopackage uses /var/tmp rather than PREFIX/var/tmp

Instrument BaseMind/MemMap to detect mutiple additions of the same thing
to the same mind.

Make it easier to use cypasswd to elevate privs.

Add ability to create other types of avatar.

Investigate -static-libgcc for partially static version of binaries for
distribution.

autopackage should start server

Set up python environment during test, so they import from the source tree.

Find out why locks up when it can't load ruleset.

Add a new kind of programmable mind, for babysitting player characters.

Provide python access to the game config.

Prevent soft attributes being set with the names of known properties.

Set name from client.

Setting attributes needs to be re-done more complex. Reporting divided
into scopes, and reporting done based on what really happened, not what
the Set wanted to happen.

Move the stuff that generates vast quantity of test Atlas data into
its own class, so other things can use it.

Complete the work on property exercising tests.

Fix python code which uses PyMem_DEL to use PyObject_Del which is the
right thing now.

Minds are getting properties from the core factory, because it is now accessed
as a singleton. This cannot stand.

Add a humanoid base class, putting default character bbox and the like in
there, plus decays="skull".

If I attach a property that listens out for delete ops, and creates things,
do the returned ops still work okay? Ie does the deleted entity stick
around long enough for the operation to get dispatched, even though it has
been removed from the world map. If so, could use this to handle creating
corpse, bones etc.

Implement some kind of helper mechanism which monitors ops going to the client
and if some match a certain template, it sends hints in the form of emotes.

Move metabolism into a property, ensuring that Character becomes a cleaner
class. Implement death better, creating a skeleton with a named skull.
Mod the lich code to use the name on the skull when creating the skeleton.

Take another look at the scheme used in mind code to purge entities
it thinks are bad.

Add an operation to account allowing the client to add a mind to its
Character. When a Character has internal and external mind, ops from the
internal mind should go only to the externalMind.

Add an option to put a python console on stdio. See PyRun_InteractiveOneFlags
to see an example of a functio which takes a line, and executes it in
the way that the interactive interpretter does.

Implement GUISE property.

Atlas::Message::Element has TYPE_NONE, so we have a conceivable way
to signal clearing of an attribute. Basically only possible soft attributes
unless we want to make the Atlas::Objects code hideous. If we are going to
find a way to signal this to the client, we need to add it to Atlas-C++.

How do we clear a Property if it is specified by Update arg, but is no
longer set to anything? Need a way for force it.

Make updateProperties read-only perhaps? Needs to clean out properties.

In GuiseProperty, need to ensure that  Set operation is simply a trigger
for an update, so we can do things efficiently. A signal triggered
by destruction or container change should trigger a Set(guis={}) which
once it gets to the SetOperation handler gets its arg re-written, I guess
the only option is the complete value.

Strip most operations out of the mindFooOperation() interface, as all soft
ops now go via scripts, if at all.

Make sure all properties override correctly. Check const.

Look at PyOplist and see if it would be better to embed the object rather than
have a pointer.

Consider, can we pre-fetch and cache the python object involved in calling a
hook?

Plough field, grow veggies. Carrot turnip.

Add code to EntityPropertytest to cover setting by ID.

Can we make client connection code more generic, getting rid of the
nasty merged TCP / UNIX stuff, and sharing code between tools and client.
Perhaps even totally generic for server and client.

Add log rotation /etc/logrotate.d/foo to rpm.

Improve pig death handling. Death is effectively just removing the mind
state, so do so. Also think about disconnecting the incoming side
of external mind. Perhaps interact in some way with the movement state?

Ad physical constraints system, which if move op comes, it is filtered
or transformed by it. For example, in a structure, elements of that
structure would be contrained so that they translated move ops into
move ops of their parent entity, the structure itself. This should be
possible using the generic idea of properties that handle operations,
and gives us a use case example for how a given property might need
to filter or override an operation.

datagram notes: see skstream TODO. Idea: When a broadcast op arrives at
the Connection, route it to an object handling datagram comms for a given
set of clients, and it caches the object, and notes the target address.
It then builds a pool of target addresses for the cached op as the
op is broadcast around the clients, and then later, in the socket loop
code, it then handles sending the data out. Alternatively it could 
serialise when it first gets the op, and cache the serialised data
in the stream, noting the identity of the operation so that it can
resend it. As long as it holds the operation smart pointer, no
other operation can arrive with the same address, although another one
later may easily have the same address once the smartptr releases to the
memory pool. As soon as another op arrives for transmission, it should be
okay to release the previous one, as it is not coming back.

Why handle sight_create_operation in NPCMind when the implementation in
BaseMind does everything fine, and we can handle the ownership in the
add_map() hook?

Should Unseen be handled in BaseMind -> MemMap rather than taking the
hit in the python code?

Replace hasAttrFlag which isDefaultFoo for efficiency.

rootWorldId should be a parameter to WorldRouter, not hardcoded.

Make ServerRouting pluggable by replacing with NodeRouting subclass, or
something, which might contain more stuff to handle being a node in a
distributed server. Might also be necessary to replace WorldRouter, which
will be no problem, as everything currently refers to it by its base class.

Fix appear disappear for instantaneous edit move ops.

map and list attributes on python objects are a problem, because the
wrappers copy then in getattr, meaning that modifications are lost.

Key player owned property, like houses and mounts should perhaps be listed
in the account charlist, and thus in the connection objects list, allowing
direct external control.

Read readline docs, and sort out good way of ensuring output does
not mess up prompt.

Make sure client can't get the impression it has taken over a non character
entity.

In next series, PARENTS on Atlas objects should be a vector.

Make logging task rotate the tree to flat over a tick interval, which
removes the issue of the progress glitching half way through the task,
as long as the rate is set to zero for the tick while the tree falls.

When dispatching a unicast op`to an entity, check if its
flags change for zero to non-zero as a result, and if so, add it to a queue
to be commited to database later. This even allows for immediate effect
ops to be grouped into a transaction perhaps. It might be necessary or
apropriate to guarantee that immediate ops are dispatched immediatly
rather than returning to idle if a certain number of ops occur.

Implement stacking basics with the active code in a property, and wrappers
in a base C++ class. Once properties can directly handle ops, less of a
problem, and the base class goes away. Stacking is explicit and driven by
mind and client.

Remove scriptSubscribe functions.

Get rid of Entity::m_attributes by making a SoftProperty class for adding
arbitrary properties to entities. Saves some lookups I think.

Combine and Divide need to ensure the atomicity of the operation, ensuring
that if creation fails, the whole thing fails. Without its not safe. Should
either allow changes to the original entities to be specified?

Add a task to cut things in half, to be used on materials.
Take a unit vector vertically upwards, transform by the entities transform
and use the resulting vector to determine which way is up. This axis and
the axis which closely matches the direction of the acting entity to the
centre of the material will be used. The position of the cut is defined by
the position clicked on, and the width of the cut should be defined in the
script somewhere.

Add trenching rule, and perhaps think about a generic task that can allow
someone to help someone else do the task they are doing.

Add property system, with property classes registered with entity factory,
and stored in the entity class object. Implementation should avoid looking up
excessively in dictionaries at entity instance time. Instead the work should
be done at class creation time. In the long term, properties defined by
scripts should be required. Reduce the role of C++ inheritance in what
properties things have, and instead put more on the bass class, and perhaps
use flags to indicate whether they are in use.

Make use of wrapTask().

Hmm, when logging out an account, the characters from that account, do
they remain in the connections dictionary? Is this bad?

Separate out IG_OP_SWITCH from OOG_OP_SWITCH. Very little overlap.
IG Does not have: GET, ERROR, INFO, LOGIN, LOGOUT, USE??? (should fix),
                  ADD, CUT
OOG Does not have: ACTION, APPEARANCE, DISAPPEARANCE, COMBINE, DELETE,
                   DISAPPEARANCE, DIVIDE, ERROR, INFO, MOVE, SIGHT,
                   SOUND, TOUCH, USE, WIELD, ADD, ATTACK, BURN,
                   CHOP, CUT, EAT, NOURISH, SETUP, TICK, UPDATE

The w2m*Operation code does only 2 things:
  It checks for Setup and Tick ops whether they are for the mind, which
  we can do in the mind code.

  It filters based on drunkness.
Both can go, removing the mechanism altogether.

STUN can be used for NAT detection. Useful? UDP only. Still useful.

Perhaps it should be possible to specify class data about the hard coded
classes in data/*,xml.

In order to store class related stuff without having to store it on
the instance, might need to have a type class which each Entity has
a pointer to. Should it also be possible to specifiy different statistics
classes in data/*.xml?

Add a base class for all active mobile characters in mason.xml, and set
up the essential statistics values. I am not sure but there may still be
issues with specifying class inheritance in the rules.

Test account and avatar creation from client when database is down.

Once SEQ has replaced STAMP in Atlas-C++, use it instead of serialno
in Tick op args.

Note that tp_new should do essential non-repeatable initialisation, like
calling in place constructor. Current newFoo() functions in the Python
API code do not cause the types tp_new or tp_init to be called. Need to
work out why, and see if changes are needed.

Add media for boots, bowl, cow, flower, hat, knife, leaf, loaf, statue, stool,
and longtable

Need to work out a sane way to handle udp socket for sending to multiple
clients quickly and efficiently.

Add short varconf args.

Make gobos rob after ganking.

Perhaps entities can have an Atlas Anonymous attached to avoid newly
constructing one every time look is called. Ref counting objects mean
no copy is required.

Add pickaxes, and trowels, and knowledge about tools to the tool merchant.

Sequence of events when database goes down:

2006:01:22 17:58:23 NOTICE DATABASE: FATAL:  terminating connection due to administrator command
2006:01:22 17:58:23 ERROR Got database query complete when no query was pending
2006:01:22 17:58:37 ERROR newId(): Database query error.
2006:01:22 17:58:37 ERROR DATABASE: server closed the connection unexpectedly
        This probably means the server terminated abnormally
        before or while processing the request.
cyphesis: WorldRouter.cpp:288: virtual Entity* WorldRouter::addNewEntity(const std::string&, const Atlas::Objects::Entity::RootEntity&): Assertion `!id.empty()' failed.
2006:01:22 17:58:37 CRITICAL Aborted

Notice there is often a deley before the third event, but even so it might
be possible to bridge a gap in database availability with some kind of
local ID generation. Anyway, clearly we are notified that the database
is going down quite some time before it causes, so we should be able to do
something about trying to reconnect. Might need to separate the
server Database Idler from the Database socket, so the idler can manage
attempting to re-connect.

Code using "unit_vector_to.." is probably only working in the same
container, and should probably be fixed to work with distance_to().

In operation_new, and other places where keywords are used, iterate
over the keywords rather than checking for a number of values. Should be
more efficient, especially when the kwds are empty. Also allows errors to
be detected better.

Make more things emit suitable action operations, especially picking up,
dropping, and combat.

Character.statistics from python needs to use the statistics script to wrap
it.

Should be able to use PyModule_New() to add submodules to existing modules,
rather than the messy dictionary hack now used for some.

When checking type of a python object, use PyObject_TypeCheck() new in 2.2
especially when inheritance is involved.

With the new way python types are defined, it may be possible to get
rid of separate wrapper and script objects, and have the script inherit from
the wrapper directly. The C++ pointer would have to be added to the structure
later, once the script object which inherits from the wrapper base class
has been returned. This means no access to the core object allowed during
__init__(). Problem may arrise when checking the type of the script to
see if it inherits from the wrapper class. Is this possible?

Py_Location now holders pointer to owning Entity if any. Now we need to
incref and decref in the important places.

We need to be able to check if things are visible from goal scripts, so
a MemEntity version of the Entity wrapper is required.
This would mean we could make buy_thing goal expire when seller goes out
of sight.

The getTickAddtion calculation is almost certainly redundant. We almost
certainly worked in out in previous call to generateMove().

Add face() to buy_livestock and related goals.

Modify mindMap so that entities are visible if they get updated.

Once Script returns an int which differentiates between an error, and
a missing method, then mind reference in PythonMindScript can got, and
error can be reported in BaseMind or somewhere similar.

Once stored python wrapper is done, the wrapper can be specialised for
Character so that task related code is exposed.

Don't do the same bullshit help every time the user clicks on a helping NPC.
Bugs: Crash when fire burns. (sear)

Look up upgrading the python API usage to 2.2 spec. In particular
look at generic attribute handling, PyType_Ready, inheritance etc.
Method doc strings.

Use getProperty to implement a surface property, and integrate into the
height adjustment code.

Do any Python types with have an _attr member initialise it before
they have to in setattr? Py_Entity/Thing used to.

Character jumps to the bottom when swimming.
Jumping to bottom is because when the character rises above water
the movement code assumes it is walking, and then height is constrained 
accordingly to terrain.
Character/Pedestrian needs to handle surface properties, so it can't walk
up steep slopes. Also need to handle jump, to get down steep slopes the quick
way.

Lobby accounts still indexed on string IDs. Good or bad?

Should ImmutableProperty inherit from Property, or the other way round so
that implementations of get and add can be shared? Yeah.

Write test for SignalProperty.

In cycmd, use flag to indicate when output is written, so it is possible to
identify when at prompt, and move to next, and also possible to more cleanly
redraw prompt, rather than forcing it every time codec->poll() is called.

ForbiddenThingFactory::duplicateFactory could return PersistantThingFactory
so its possible to add more abstract factories.

In order to have attribute defaults inherit from parent classes,
the code must first store the unmodified defaults direct from the rule
in a separate place. Its main attributes should then be the result of merging
those with its parent. This ensures that the result is always right, without
having to walk all the way up to GameEntity. It is also makes propagating
modified attributes down the tree easier, as long as a factory stores
a list of its children. This means we have two compelling reasons why the
parent factory needs to be available when the child is being installed.

Handle SQL escaping of attributes encoded string before persisting.

Implement tracking terrain surface, and preventing climbing of steep terrain.

Implement data driven gui dialogues, in Sear and perhaps equator.

<map>
  <list name="parents><string>dialogue</string></list>
  <string name="label">Dialogue</string>
  <list name="contents">
    <map>
      <list name="parents"><string>vbox</string></list>
      <list name="contents">
        <map>
          <list name="parents"><string>label</string></list>
          <string name="label">This is a dialogue</string>
        </map>
        <map>
          <list name="parents"><string>hbox</string></list>
          <list name="contents">
            <map>
              <list name="parents"><string>button</string></list>
              <string name="label">Okay</string>
            </map>
            <map>
              <list name="parents"><string>button</string></list>
              <string name="label">Cancel</string>
            </map>
          </list>
        </map>
      </list>
    </map>
  </list>
<map>


        -------------------------Dialogue------------------------
        |                                                       |
        |   A dialogue                                          |
        |                                                       |
        |     --------------------     -------------------      |
        |     |      Okay        |     |     Cancel      |      |
        |     --------------------     -------------------      |
        |                                                       |
        ---------------------------------------------------------

Are attributes inherited? I think not. Need to be.

Carefully use flags to check for illegal stuff from client/mind ops.

Walking army of the undead, daily.

Spatial iterators, for map have a reference to a const_iterator, and filter
while incrementing. Iterate between space(bot_left, top_right)  and end().

Don't update POS in database if VELOCITY is non-zero.

strlen.com

Predators should now use combat code to defeat prey before eating, and
then Eat op on character should only work on incapacitated characters.

A bunch of stuff in Character::externalOperation can go if we don't care
about ops having serialnos.

Move contents of mindUseOperation to UseOperation, and have mindUseOperation
filter ops like it should.

Combat system needs to depend on character stats, armour, clothing and
weapon at very least. Probably need a class to encapsulate important
processed stat information for a character. This makes it harder to
have a fully configurable combat system.

Define new class Volume which contains the set of points and normals
required by the collision code. Cache the volume, and bounding radius
of entities in Location. bounding radius is very easy. Add a course
collision check based on bounding radius.

Not sure destination based movement is working right if destination pos
changes due to LOC change.

Fix collisions. Leaving needs to be the inverse of entering, and this
implicitly means we need to check collisions with the parents' children.
We could also probably do with a very course check to make the whole thing
cheaper.

Collision code would be more reliable if collisions were check with
current parent's siblings, as well as entities siblings.

Make sure all Property classes have add(Entity)

Task tick ops need to embed the ident of the task, to ensure a replacement
does not cause a problem.

Modify Attack handler so it is the attackee that creates the task object,
so attacking a pointless target has no effect without any smarts required
in mindAttackOperation().

We can probably block all ops to mind when its unconcious from
the Character class.

Make Connect and Attack standard Atlas op.

Sort out issue where carrying a living tree kills people. Caused by
eat op from tree.

Attribute modifiers should be a new low-level primitive on Entity,
like property. They should be done before attributes are set from data,
but after default attributes are set. Scale control variables should
be assumed to be 1 initially for the purposes of scaling.
A function like merge should be used to apply scalars. It needs to be
able to copy the modded data into Atlas for reporting back to the client.

Fix dodgey collision code which causes structures with complex parts to cause
tight loop conditions.

It should be possible to make trees fall so that they are parallel with
the terrain, if a mechanism is available to determine normal of the
supporting surface.

Does it matter if World gets a delete op when status becomes < 0? It
shouldn't, as the delete op should be ingored, so World does not need
a Set op implementation.

Sort out a way to move world functionality into a script.

On #python talk to deltab TFK or #pyrex.

When reloading a python module, try to load it even if it didn't load before.

Prevent forbidden attribute from leaking through in move ops from client.

Re-code chickens so they flee on contact, rather than on sight.
Fix lych and skellys.

Implement swimming, which requires constraining the updated pos in the movement
code to be sure of getting the right Z. Try and do some direction stuff in
the sear interface.

Clean up old movement code, get rid of Movement::m_velocity, and perhaps
m_orient.

When getMoveUpdate is first called in moveMoveOperation, it doesn't really
want an operation, just an update of the position.

Add swimming to Pedestrian. Try and add floating by default to non aquatic
creatures.

Move Create handler from Entity into Thing, as everything IG inherits from
Thing.

Make an Atlas encoding to describe basic layers.

Implement buying clothes to be worn. Garment base class, use wield operations
to use.

Implement spawnpoints, and separate mason and werewolf locations.

Make sure python object references aren't leaked in script factories.

Implement subsystems on server object. Allow Admin to fetch the subsystems,
like "configuration", "policy" etc.

policy should include things like:
   Account creation on the fly.
   Number of characters per account.
   Number of character played at the same time per account.
   Visibility of player on character and character on player.
   Character removal from world on logout.

Installed types from the client need to be persisted in the database.

Create harness device which is a number of entities connected by ropes.
Consists of hook, and a number of ends to be held by people. Each end is
attached by a rope entity to the thing to be moved. To attach the hook,
it is wielded and used on the target. Each person the wields and uses
their ends. When enough people pull, the target moves. Vector of travel
is the average of the distances to the people pulling.

Add use of pickaxe to split rocks. Initial rock in ground could be huge,
and require splitting, or heavy equipment to move. Rock can be shaped into
stone billet for use in building using a chisel.

Add operation Increment which allows deltas to be made to attributes.
Important for atomicity in delayed events. Propagated as Sight(Set).

Grass should dry out.
Earth and sand should return to the soil.
Sand can be made into a sandy area using a tamper.
Digging earth could create a field area.
Might need to notify entities when their parent changes.

Code up projectile movement as a first test of entity movement.

Sort out so lobby had a real ID.

Code up allowing accounts to create rooms, and guilds.

Optimise down the number of calls to iterator::end in mindUseOperation

Add a reach attribute to tools which tells the client how far the NPC must
be from the target before they can use it on something.

Fix Creator::LookOperation so that it doesn't return anything if no
match can be found. Also it should probably not accept ops with TO already
set.

Add cydumprules to the man pages.

Clean out Python operation API, as its full of unused and useless functions.

Slave or Peer servers need to negotiate types at startup.

Make the butcher more helpful to n00bs.

Implement a Tool base class which eliminates the need for tool scripts - 
handles the necessary op conversions driven by data.

Make sure stamp is updated in MemMap and checked, and implement Unseen.

Implement trivial combat, and code up a bunny bashing quests for the hard
of thinking.

Add ticker callback mechanism to WorldRouter, which calls callback whenever
a tick is required. Will reduce the cost of the op queue by making it smaller,
and should be cheaper than tick ops. Needs to be carefully designed. Can handle
stuff like one-shots, as well as regular ticks.

Spec an op similar to use, but for things which are just used by themselves,
like buttons, valves, levers etc. Target has operations=[...] just the same,
and the arg of the new op specifies what op to do, but the Character just
needs the one gateway.

Implement Task interface, which represent enduring tasks, including combat.
Could also include destination based movement. Task needs a name, and an
accessor for it, so it can be used as a private Property.

When calling NPCMind.face when buying an item, for some reason the velocity
of Pedestrian is valid and set to a weird value. This is because the
target position where the merchant wants to be is at a different z value
from where the character ends up. This is a general problem with moving
to pre-defined positions.

We could move the loop into ServerRouting, rather than CommServer.
Rename CommServer::idle to CommServer::poll or something like that.
Perhaps we don't even need idle any more. Idle objects would then
be owned by ServerRouting rather than CommServer. CommServer would
then be almost fully generalised. In order to lose the reference to
ServerRouting in CommServer, the listeners would have to have this reference
instead - move the specialisation into the listeners.

Does sightFooOperation etc. in BaseMind.h have to be virtual? I think not.
Yes it does, as its overriden in some client code.

CONTAINS could be some kind of spatial set of buckets for efficiency
when doing collision detection, but if this is not to be true for all entities
then the mechanism for modifying CONTAINS needs to be virtualised, and
made a method on the container/LOC. If the spatial stuff is to work then
the entity needs to be removed while it still has its old coords, and added
to its new container with its new coords.

We should be able to look at the attributes of an python instance to
determine what operations it needs to be subbed to. It doesn't have a
dictionary, but it does have the methods as attributes.

Make sure that goals involving movement don't issue a move op unless its
necessary. ie check to see if we are already moving in the right direction.

Fix Movement/Pedestrian to handle destination based movement where LOC
changes. Just use distanceTo as the velocity vector.

The spot_something goal is a hack - need something better. Probably need
some kind of Knowledge about target entity. Give the Knowledge predicate
as an argument to spot_something(), and add Knowledge with that predicate
once something has been spotted. For example
spot_something('lumber', 'spotted_lumber')

mind.things in NPCMind seems to be completely based on the name attribute,
though it seems like it would make more sense for it to use type some of
the time.

Each entity could have a Mode object which controls how its movement/position
is simulated, including the effect of gravity etc. This would be associated
with a mode string.

If the character moves an entity into another similar entity, then
we should create a Pile. This can be detected in mindMoveOp().

Currently no mechanism to inform client/mind that the ID they just
specified is gone. Need to think of something, and make sure mind
deals correctly. Something like Unseen operation.

Can Property mechanism be used to handle raw Python data as properties?

Sort out the issue of un-initialised POS, ORIENTATION and BBOX in the
database.

MemEntity needs some kind of reference flag/count if a python object
is holding a reference. Probably as well to ref-count all IG entities,
then we can hold a reference in the op queue, and avoid lookup up the
FROM at dispatch time. Would also allow entities to hold pointers.

Fix unit_vector_to in python interface to make sure it doesn't cause
a normalise() abort(). Probably re-write to use relativePosition() which
may need to be fixed to give the right direction. The correct direction
should be the coordinate space that the observer's position is in. It
is probably currently returning it in the entities local coords.

Stop creator characters for getting filed into the accounts_entity_ent
table.

Transforming with an invalid quaternion creates an invalid vector or point.
We must not do it. See FIXME in WorldRouter.cpp.

Is it necessary to copy new_coords in Pedestrain::genMoveOperation()?

Sort out trees thrashing database. Postpone until we have done something
about database transactions.

Centralise serialno assigment on IG ops, checking for 0 to see if we should?

Sort out FIXME in Creator::operation().

Character creation should not fail if creating its bootstrap inventory fails.
Errors from coin creation are confusing clients.

Convert FormatedXMLWriter into a templat that can drive any Atlas codec.
Thus we can have any Atlas Codec output in formatted human readable form.
Formatter can be a generic non-template Brige that sits between Encoder
and Codec.

It might make sense to keep a pointer to the entity an operation is from
in the queue, if its available at the point when we store it. How do we
then make sure we don't hold bad references?

Report error properlly in MemEntity when clock skew is detected.

Try and avoid removing stuff from the mind as soon as its been added. Perhaps
by checking the iterator ID on insert?

Try out dynamic cast rather than string test to identify ops in WorldRouter.

It would probably be easier to move extraction of parents from a new entity
to world.addNewObject() to avoid duplication.

Use "REFERENCES foo ON DELETE CASCADE" SQL to make sure character table
relations are removed when a character is deleted, or an account is deleted.

So, we have skill, which is a way of mapping tool use into actions.
How about tasks, which are a way of giving persistence and state to actions?

Sort out deer animations.

Add grasing.

By adding a skill class to be referenced by character, and defining Teach 
(transfer skill) Sling (stop wielding tool, and place somewhere convenient)
we can have almost a complete system. Implicitly, the click action when a tool
is wielded is to use that tool.

Re-work the way PyEntity and PyMind are defined so the inheritence is
available, and open up the scope for exposing more directly the functionality
of other entity classes.

Stop creating new objects from causing so much activity. Perception of the
new object must be based on its visibility. Perception of its deletion
should also be limited. Implement LRU in mind.

Upsidedown chickens suck!

Use tool, Wield op and Use op.

Add beet.

Look at me Swimming!

Debug skellys.

Make lych move. Construct skeleton nearby.

Handle modifying bbox proportionally to parameters.

Linears and stuff.

Path finder based roads and stuff.

Create pig pen.

Generalise money_transfers in mind to store general information about
all transfers of ownership. Preferably in knowledge.

Make chickens afraid of wolf.

Make vis re-calculated on bbox change.

Make walking speed depend on height.

Make cyclient more robust about receiving random ops.

Implement spawn points in the EntityFactory.

Verify that the persistant code does not insert entities into the world with
invalid location data. It shouldn't.

Fix movement bug with destination based movement after collision. Ammend
find target to be derived from velocity.

Fix or get rid of cyphesis-setup

Fix usage of map.get in BaseMind and NPCMind

Make ExternalMind inherit from something higher that BaseMind. It has so
few features.

It may be possible to get rid of getXyz() (crappy absolute position)

Its really not necessary for WorldRouter and its base to be so virtual, or
inherit from BaseEntity. Get rid of that, shift all the serialno stuff into
base.

Add time to location, so we can stamp update time, and always calculate pos.

We can neglect to send appearance if we are about to send Sight Move.

distanceTo does not take into account orientation.

Sort out putting everything at terrain height. This may require some strange
stuff.

Invesitage interaction between mind/body WRT type. We shouldn't ever use
the type string in Atlas.

Get rif of Entity::m_name, and other related pointless static attrs.

Fix Entity::addToObject to be more efficient with contlist

Make the server easier to kill.

Enforce well-formed args and parents on IG ops centrally.

Real sight ranges

Do minds delete stuff from memory? Replace Entity with a special class
for memory entities, includin some kind of LRU thingy.
Implement LRU culling to minds, only for things with empty contains.
MemMap::lookId should probably not be exposed to the python API

Add Restore op if required which does the same as Setup, but for restore.

Make sure we don't schedule database maintenence if its already doing it.

There is probably a problem with getLocation bailing if LOC is not of the
data from the mind code's point of view.

Why the hell is there so much mind activity on database restore.

Take precautions to ensure multiple looks don't get stacked up in the MindMap.
Probably best done by making additionsById a map.

Add some simple sound op examples

Make Forest a non-solid bbox

Fix problem with vertical movement. (See BUGS)

Debug collision with sty.

Make cyphesis less reluctant to shutdown. Check for exit_flag in more
places. Add second flag set if other signals are used other than interrupt
or term, or if those signals are used twice. This could bypass all the
memory freeing to ensure clean fast stop.

Need to profile why startup takes so long - we are chewing a lot of ops.

Can we run our own RDBMS in the event that root access is not available.

Modify var dir for socket so it is actually the right place.

Run "SET autocommit TO 'off';" on connection to database, and run "COMMIT;"
every 30 seconds (or so).

Make database maintainance intervals configurable.

Sort out character relation so it has the right foreign key stuff.

Looks like zero collision time results in move then stop being sent
almost immediatly. Check for it, and send nothing. This may mean
re-ordering the movement code. Possibly checkCollisions needs
to be earlier.

Modify Movement and Pedestrian classes so they handle restricting an
entity to their parents constraints. In the case of Pedestrian, this
means walking on the ground.

Clean the database. Use VACUUM once an hour, and probably VACUUM ANALYSE
and VACUUM FULL each once per day. REINDEX may also be required.

Sort out socket address re-use, and lingering.

Long term, try and sort out the way object factories, scripts, and atlas
inheritance are handled, so they are a bit more coherant.

Modify the logging code so that it mangles script output a bit less.

Fix up python checks so they work with a prefix other than /usr

Is listen socket getting opened before it will accept or negotiate because
more work is being done before poll/select occurs.

Fix up cypasswd to allow creation of additional admin accounts.

Think about adding UPnP here or to skstream (or both)

Use PyInstance_New to create an instance given a class.

Use PyModule_AddObject(), PyModule_AddIntConstant(), and
PyModule_AddStringConstant() when setting up the python consts module.
(new in version 2).

Look at re-writing python API code to work with python GC

Look at using zipfiles to store entrie trees of python files for a ruleset.

Still plenty of python object leaks. Need to carefully see if references are
being handled right in the mind code.

Implement constraints on entities, which have to be checked before movement
is allowed.

Put in different high level exception catchers, to differentiate between
exceptions caused by a client, which should result in a kick, and bugs in game
which need to be logged.

Mind state is still utterly unpersisted, so creatures are waking up brain dead
- mind does not even get kick started with a setup op.

When deleting an entity, need to deal with reparenting its children in the
database.

Experiment with BEGIN / COMMIT blocks to reduce load on database. A
possibility is starting a transaction, and then commiting, delaying if their
are requests which have not yet been sent. This of course pre-supposes that
the mechanism for sending queries to the database asynchronously has
been done. It is probably acceptible to only accept queries that do not
return any tuples, and then the asyncronous recieve mechanism doesn't need
to worry about who wants the tuples.

General TODO

  Generalise and virtualise the collision code.

  Implement jump operation, which specifies target, and comes back with,
  a sight of a jump which has the starting velocity, and finish position.
  If the client sends only velocity, then something else happens. Add
  a method to Pedestrian to handle it.

  Add Feel as the counterpoint to Touch, as Sight is to Look.

  Implement piles.

  For entities which have a bbox, which other entities do not collide
  with, such as geo entities, provide a virtual methods which allows the
  collission code to check whether entities within this bbox should
  be moved into the bbox entity. Should work fine for irreguler shaped
  things, as long as bbox is kept up to date.

  Ensure that maxmass set in python has some effect in C++, and investigate
  other related attributes.

  Connecting to other server: Make class peer of CommClient called
  CommConnection or something which is basically the same, but implements
  connecting instead of accepting. Might even be able to merge the code
  in, or make it a template. Make object which inherits from Connection
  called ServerConnection which is created and linked to CommConnection
  which handles pushing operations from the other server into the
  WorldRouter. The question now is, how this is managed at the other end,
  and what is done with operaions generated by this server due to
  operations from the other one.

  Add suspend functionality, which stops the advance of time, and
  thus suspends all mind activity. Could also inhibit broadcasts. Effectively
  puts the server in bulk maintenance mode, from which NPCs should be
  removed. Should consider the effect this will have on NPC memory,
  and whether or not it can be rebootstrapped.

  Looking at contains attribute currently only applies sight ranges in
  world entity. Need to apply sight ranges in all entities.

  Add services features, and test them in equator.

  Fully implement stackable objects.
  Use combine operation to deal with making more than one object into one.

  Add sending of touch op on collision.

Required for werewolf:

  Implement calendric time using WorldTime and DateTime classes, so nighttime
  and moons are properlly handled.

  Implement sleeping.

  Sort out a reasonable way of representing day and night to client. Look
  up info on Durals astronomy. Weather (clouds, snow, rain, thunder and
  lightening).

Required for mason:

  Create a skills system which the action is passed to, and the skill
  returns the resulting operation to the world. This skills system
  would be handling by the character class, in the mindXxxxOperation()
  methods. The skill would be an object with a reference back to the
  character it belongs to, and a method that is passed the action taking
  place. It would return operations to be passed to the world which carry
  out that action to the extent of the ability of the character. Some
  skills will just do nothing, like the ability to wave, or shout. or
  maybe the shout action could decide using a skill how loud the shout is.

  Implement the Mason raw materials.
  
Possible ideas:

  Add fully featured database persistance.

  Persistance system is naive right now. It does not take account of that
  fact that characters need minds, and it stores the world object.
  Persitance is now sorted so it loads the world hierarchicly, but
  it still does not handle minds and things. Problems with current
  code include velocity being stored, and bounding boxes not being
  recovered.
  Basic C++ code for supporting saving and loading of mind state is now
  in place, but support needs to be added into the Python NPCMind
  class to store the data it requires.
  Code is still required to store the state of the operation queue.
  Restoring of accounts from database requires re-connecting characters
  too.

  Get system working as an AI client to another server. This would also
  be a good time to get cyphesis working as a mindless server, without
  any AI code.

  Route finding for the AI. NPCs already have symbolic knowledge of places.
  All we need is a mechanism for describing that two places (or nodes) have
  a direct route between them, and then the mind can build a graph which
  allows them to find a route. We also need to provide a mechanism so that
  NPCs know about a particular entity. This can be done by sending a generated
  sight operation.

  Sort out collision detection wrt moving alongside an object in close
  proximity, and add CD for two moving objects. Basically we need sliding.
  along an object. This can be done by zeroing the velocity along
  the axis perpendicular to the collision. Obviously we need to add
  a mechanism for establishing which axis is perpendicular to the collision.
  This now works, but the direction the moving entity is facing is sometimes not
  modified.

  Modify map to make more use of stamp.
